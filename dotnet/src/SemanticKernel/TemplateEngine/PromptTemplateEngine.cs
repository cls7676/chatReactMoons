// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Orchestration;
using Microsoft.SemanticKernel.TemplateEngine.Blocks;

namespace Microsoft.SemanticKernel.TemplateEngine;

/// <summary>
/// Given a prompt, that might contain references to variables and functions:
/// - Get the list of references
/// - Resolve each reference
///   - Variable references are resolved using the context variables
///   - Function references are resolved invoking those functions
///     - Functions can be invoked passing in variables
///     - Functions do not receive the context variables, unless specified using a special variable
///     - Functions can be invoked in order and in parallel so the context variables must be immutable when invoked within the template
/// </summary>
public class PromptTemplateEngine : IPromptTemplateEngine
{
    public PromptTemplateEngine(ILogger? log = null)
    {
        this._log = log ?? NullLogger.Instance;
    }

    /// <summary>
    /// Given a prompt template string, extract all the blocks (text, variables, function calls)
    /// </summary>
    /// <param name="templateText">Prompt template (see skprompt.txt files)</param>
    /// <param name="validate">Whether to validate the blocks syntax, or just return the blocks found, which could contain invalid code</param>
    /// <returns>A list of all the blocks, ie the template tokenized in text, variables and function calls</returns>
    public IList<Block> ExtractBlocks(string? templateText, bool validate = true)
    {
        this._log.LogTrace("Extracting blocks from template: {0}", templateText);
        var blocks = this.TokenizeInternal(templateText);
        if (validate) { ValidateBlocksSyntax(blocks); }

        return blocks;
    }

    /// <summary>
    /// Given a prompt template, replace the variables with their values and execute the functions replacing their
    /// reference with the function result.
    /// </summary>
    /// <param name="templateText">Prompt template (see skprompt.txt files)</param>
    /// <param name="executionContext">Access into the current kernel execution context</param>
    /// <returns>The prompt template ready to be used for an AI request</returns>
    public async Task<string> RenderAsync(
        string templateText,
        SKContext executionContext)
    {
        this._log.LogTrace("Rendering string template: {0}", templateText);
        var blocks = this.ExtractBlocks(templateText);
        return await this.RenderAsync(blocks, executionContext);
    }

    /// <summary>
    /// Given a a list of blocks render each block and compose the final result
    /// </summary>
    /// <param name="blocks">Template blocks generated by ExtractBlocks</param>
    /// <param name="executionContext">Access into the current kernel execution context</param>
    /// <returns>The prompt template ready to be used for an AI request</returns>
    public async Task<string> RenderAsync(
        IList<Block> blocks,
        SKContext executionContext)
    {
        this._log.LogTrace("Rendering list of {0} blocks", blocks.Count);
        var result = new StringBuilder();
        foreach (var block in blocks)
        {
            switch (block.Type)
            {
                case BlockTypes.Text:
                    result.Append(block.Content);
                    break;

                case BlockTypes.Variable:
                    result.Append(block.Render(executionContext.Variables));
                    break;

                case BlockTypes.Code